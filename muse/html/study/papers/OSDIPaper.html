<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>USENIX Symposium on Operating Systems Design and Implementation</title>
    <meta name="generator" content="Muse">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <link rel="stylesheet" type="text/css"charset="utf-8" media="all" href="../../styles/common.css"  />
  </head>

<body>

  <h1>USENIX Symposium on Operating Systems Design and Implementation
   <!-- menu start here -->
     <div class="menu">
        <div class="menuitem">
          <a href="../../home/index.html">Home</a>
        </div>
        <div class="menuitem">
          <a href="../../emacs/index.html">Emacs</a>
        </div>
        <div class="menuitem">
          <a href="../../complang/index.html">CompLang</a>
        </div>
        <div class="menuitem">
          <a href="../../study/index.html">Study</a>
        </div>
	<div class="menuitem">
          <a href="../../services/index.html">Services</a>
        </div>
	<div class="menuitem">
          <a href="../../home/link.html">Links</a>
        </div>
      </div>
    <!-- menu ends here -->

  </h1>


  <!-- Page published by Emacs Muse begins here -->

<h2>OSDI '08</h2>

<h3>Finding and Reproducing Heisenbugs in Concurrent Programs</h3>

<p class="first">微软亚洲研究院发的paper，针对并发编程中难以发现的bug问题。</p>

<p>paper的内容主要分两大块。</p>

<p>一是如何在发现bug的时候记录下线程的运行先后(thread interleaving)，
途径是在线程API和用户程序多写一层wrapper functions，这里还有一些
其他的问题，比如只记录下了thread interleaving的话出现data race怎么解决等。</p>

<p>另外一块内容是如何遍历出给定程序运行后所能产生的结果的集合，加入
这个能实现的话那就能把所有隐藏的bug都找出来了。但是这个搜索空间
很大，是指数级的，的一个结论就是：给定一个程序有n个的线程，所有线程
共完成k条指令，那么c次占先调度后线程的排列情况数的复杂度是k^{c}的，
所以在实现遍历代码的时候必须有效的降低k和c的值。</p>

<p><a href="../../download/presentation/chess.pdf">presentation</a></p>

<p>2008.11</p>



<h2>OSDI '96</h2>

<h3>Safe kernel extensions without run-time checking</h3>

<p class="first">传统代码安全检查都需要在运行期动态的加入检查手段，引入的overhead比较
严重。这篇paper提出了一个很不错的idea，只要做一次性检查就能安全的运行
代码了。</p>

<p>首先，代码的运行者制定出一份safety policy(SP)，包括一个verification-condition的
generator，一组用来验证SP的axiom，以及代码运行者将如何运行代码的preconditon。
代码的提供者得到SP后，在提供代码的同时给出了关于这个代码安全性的证明，
然后代码运行者拿到代码后只要验证这个证明是正确的，就能放心的运行这段代码了。
所有的验证都是通过first-order logic完成的。把代码证明这个任务交给代码提供者
来做可以大大的降低运行时检查安全性所需的时间，因为检查证明的正确性比证明
代码的安全性简单多了。</p>

<p>感觉idea很不错，尽管实现起来不怎么现实（好像十几条指令的安全性证明就需要五秒
多时间来生成）。</p>


<p>2008.2</p>



<!-- Page published by Emacs Muse ends here -->
<p>
<center>
最后更新：
2009-03-18 15:01:24
</center>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-2241833-7");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

