<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Erlang的Hello World: 一个计数程序</title>
    <meta name="generator" content="Muse">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <link rel="stylesheet" type="text/css"charset="utf-8" media="all" href="../../styles/common.css"  />
  </head>

<body>

  <h1>Erlang的Hello World: 一个计数程序
   <!-- menu start here -->
     <div class="menu">
        <div class="menuitem">
          <a href="../../home/index.html">Home</a>
        </div>
        <div class="menuitem">
          <a href="../../emacs/index.html">Emacs</a>
        </div>
        <div class="menuitem">
          <a href="../../complang/index.html">CompLang</a>
        </div>
        <div class="menuitem">
          <a href="../../study/index.html">Study</a>
        </div>
	<div class="menuitem">
          <a href="../../services/index.html">Services</a>
        </div>
	<div class="menuitem">
          <a href="../../home/link.html">Links</a>
        </div>
      </div>
    <!-- menu ends here -->

  </h1>


  <!-- Page published by Emacs Muse begins here -->

<p>acm queue 9月的杂志的主题是The Concurrency Problem，力推了Erlang这个语言，其中有篇文章简单的介绍了下这个message-oriented语言。</p>

<p>查了下这个名字的读法，正确的读法应该是air-lang，这里元音a的发音和bang中的a一样。</p>

<p>文章中的第一个程序就有点令人费解，主要原因在于Erlang的语法和一般的imperative language差别很大，和functional language比较类似，但是本质上也有很大的不同。</p>

<p>以Java的一个计数程序为例</p>

<pre class="src">
<span style="color: #ff5f00;">// </span><span style="color: #ff5f00;">A shared counter.
</span><span style="color: #00cdcd;">public</span> <span style="color: #00cdcd;">class</span> <span style="color: #87ff87;">Sequence</span> {
    <span style="color: #00cdcd;">private</span> <span style="color: #87ff87;">int</span> <span style="color: #ffd787;">nextVal</span> = 0;

    <span style="color: #ff5f00;">// </span><span style="color: #ff5f00;">Retrieve counter and increment.
</span>    <span style="color: #00cdcd;">public</span> <span style="color: #00cdcd;">synchronized</span> <span style="color: #87ff87;">int</span> <span style="color: #87d7ff;">getNext</span>() {
        <span style="color: #00cdcd;">return</span> nextVal++;
    }

    <span style="color: #ff5f00;">// </span><span style="color: #ff5f00;">Re-initialize counter to zero.
</span>    <span style="color: #00cdcd;">public</span> <span style="color: #00cdcd;">synchronized</span> <span style="color: #87ff87;">void</span> <span style="color: #87d7ff;">reset</span>() {
        nextVal = 0;
    }
}
</pre>

<p>这个程序的功能不用多说了，一个同步的计数程序。它的Erlang翻译版的代码为</p>

<pre class="src">
-module(sequence1).
-export([make_sequence/0, get_next/1, reset/1]).

% Create a new shared counter.
make_sequence() -&gt;
spawn(fun() -&gt; sequence_loop(0)end).

sequence_loop(N) -&gt;
receive
{From, get_next} -&gt;
From!{self(), N},
            sequence_loop(N + 1)&lt;SEMI&gt;
        reset -&gt;
sequence_loop(0)
end.

% Retrieve counter and increment.
get_next(Sequence) -&gt;
Sequence!{self(), get_next},
receive
{Sequence, N} -&gt; N
end.

% Re-initialize counter to zero.
reset(Sequence) -&gt;
Sequence! reset.
</pre>

<p>初看这个程序自然是一头雾水，不过程序的函数式风格味还是很浓的。</p>

<p>前面提到，Erlang是基于message的，或者说message sending机制是包含在语言系统内部的，语法就是 pid ! message</p>

<p>接下来再来分析这个简单的程序。开头两行是模块和函数声明，略去。make_sequence开始这个进程，spawn/1内置函数创建一个新的进程，并返回pid到调用者。</p>

<p>初始时运行的函数是sequence_loop(0)，这个函数接收两种信息，用receive表达式声明：如果收到形式是{From, get_next}的信息，就返回当前的N并调用sequence_loop(N+1)，这样下一次收到同样的信息时就能返回N+1了；reset则等价于Java版本中的n=0语句。</p>

<p>get_next/1则是发送给pid为Sequence的进程 {self(), get_next} 这样一个信息，上面解释的sequence_loop/1函数收到这个信息后会返回一个 {self(), N} 的tuple给get_next/1，收到这个信息后get_next/1就能返回N这个值了。</p>

<p>最后reset/1函数则是发送给Sequence一个reset信息。</p>

<p>这个简单的程序里能大致窥见一些Erlang的特点，尤其是它基于信息发送的本质。</p>
<!-- Page published by Emacs Muse ends here -->
<p>
<center>
最后更新：
2009-03-18 15:01:24
</center>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-2241833-7");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

