<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>为什么Python中的self必须保留？</title>
    <meta name="generator" content="Muse">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <link rel="stylesheet" type="text/css"charset="utf-8" media="all" href="../../styles/common.css"  />
  </head>

<body>

  <h1>为什么Python中的self必须保留？
   <!-- menu start here -->
     <div class="menu">
        <div class="menuitem">
          <a href="../../home/index.html">Home</a>
        </div>
        <div class="menuitem">
          <a href="../../emacs/index.html">Emacs</a>
        </div>
        <div class="menuitem">
          <a href="../../complang/index.html">CompLang</a>
        </div>
        <div class="menuitem">
          <a href="../../study/index.html">Study</a>
        </div>
	<div class="menuitem">
          <a href="../../services/index.html">Services</a>
        </div>
	<div class="menuitem">
          <a href="../../home/link.html">Links</a>
        </div>
      </div>
    <!-- menu ends here -->

  </h1>


  <!-- Page published by Emacs Muse begins here -->

<p>Bruce Eckel的一篇日志建议把self从方法的参数列表中移除，并把它作为一个关键字使用。
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=239003">http://www.artima.com/weblogs/viewpost.jsp?thread=239003</a></p>

<p>Guido的这篇日志说明了self作为参数是必不可少的。
<a href="http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html">http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html</a></p>

<p>第一个原因是保证foo.meth(arg)和C.meth(foo, arg)这两种方法调用的等价（foo是C的一个实例)，关于后者可以参见Python Reference Manual 3.4.2.3。这个原因理论上的意义比较大。</p>

<p>第二个原因在于通过self参数我们可以动态修改一个类的行为：</p>

<pre class="src">
<span style="color: #ff5f00;"># Define an empty class:
</span><span style="color: #00cdcd;">class</span>  <span style="color: #87ff87;">C</span>:
    <span style="color: #00cdcd;">pass</span>

<span style="color: #ff5f00;"># Define a global function:
</span><span style="color: #00cdcd;">def</span> <span style="color: #87d7ff;">meth</span>(myself, arg):
    myself.val  =  arg
    <span style="color: #00cdcd;">return</span>  myself.val

<span style="color: #ff5f00;"># Poke the method into the class:
</span>C.meth = meth
</pre>

<p>这样类C就新增了一个meth方法，并且所有C的实例都可以通过c.meth(newval)调用这个方法。</p>

<p>前面两个原因或许都可以通过一些workaround使得不使用self参数时实现同样的效果，但是在存在decorator的代码中Bruce的方法存在致命的缺陷。(关于decorator的介绍可以参见<a href="http://www.python.org/dev/peps/pep-0318/">http://www.python.org/dev/peps/pep-0318/</a>)</p>

<p>根据修饰对象，decorator分两种，类方法和静态方法。两者在语法上没有什么区别，但前者需要self参数，后者不需要。而Python在实现上也没有对这两种方法加以区分。Bruce日志评论中有一些试图解决decorator问题的方法，但这些方法都需要修改大量底层的实现。</p>

<p>最后提到了另一种语法糖实现，新增一个名为classmethod的decorator，为每个方法加上一个self参数，当然这种实现也没必要把self作为关键字使用了。不过我觉得这么做还不如每次写类方法时手工加个self。</p>
<!-- Page published by Emacs Muse ends here -->
<p>
<center>
最后更新：
2009-03-18 15:01:24
</center>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-2241833-7");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

